# This must come first in this particular file.
from flask import Flask
from flask import session, redirect, url_for
from flask.ext.session import Session

app = Flask(__name__)
sess = Session()

# Import all of the controllers for your application
from application.controllers import *
from config import config

# For stress testing
#import application.stress

# We need to track session information for using the 
# admin console. This is not fully understood yet.
app.secret_key = config.flask.secretKey
app.config['SESSION_TYPE'] = 'filesystem'
sess.init_app(app)

# Set up the administrative interface
import flask_admin as admin
from flask.ext.admin import expose
from flask_admin.contrib.peewee import ModelView
from application.logic.validation import getRoles

class RoleVerifiedAdminIndexView(admin.AdminIndexView):
    @expose('/')
    def index(self):
      uname = config.flask.username
      roles = getRoles(uname)
      # print "User '{0}' has roles {1}".format(uname, roles)
      if "admin" in roles:
        # print "Role Verified"
        return super(RoleVerifiedAdminIndexView, self).index()
      else:
        # print "No Role Verified"
        return redirect("/", code = 302)

admin = admin.Admin(app, 
                    name = config.application.title, 
                    index_view = RoleVerifiedAdminIndexView(),
                    template_mode = 'bootstrap3')
from application.models import classes
for c in classes:
  # print "Adding ModelView to {0}".format(c)
  admin.add_view(ModelView(c))

# Store the username (which will have been set by the webserver)
# into the config. 
# FIXME: This is temporary. Fix with proper code for running
# under Apache/Shibboleth
import os
from application.logic.validation import getUsernameFromEnv as gUFE
config.flask.username = gUFE()



# This hook ensures that a connection is opened to handle any queries
# generated by the request. Opens every database, which is not ideal,
# but because we don't know which will be used...
@app.before_request
def _db_connect():
  for db in config.databases:
    theDB = config.databases[db].theDB
    theDB.connect()

# This hook ensures that the connection is closed when we've finished
# processing the request.
@app.teardown_appcontext
def _db_close(exc):
  for db in config.databases:
    theDB = config.databases[db].theDB
    if not theDB.is_closed():
        theDB.close()
